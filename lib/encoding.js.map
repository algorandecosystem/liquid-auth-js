{"version":3,"file":"encoding.js","sources":["../src/encoding.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport { decodeAsBytes, encodeBytes } from './hi-base32.js';\nimport { createMethod } from './sha512.js';\nconst sha512_256 = createMethod(256);\nconst chars =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nconst ALGORAND_PUBLIC_KEY_BYTE_LENGTH = 32;\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nconst HASH_BYTES_LENGTH = 32;\n\n/**\n * A constant string containing the error message for a malformed address.\n * This message is used to indicate that an address does not adhere to the expected format or structure.\n *\n * @protected\n */\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'Malformed address';\n\n/**\n * A constant string that represents an error message for an Algorand address with a bad checksum.\n * This message is used to indicate that the checksum of the provided Algorand address is invalid,\n * which typically occurs when the address is incorrectly formed or corrupted.\n *\n * @protected\n */\nexport const ALGORAND_ADDRESS_BAD_CHECKSUM_ERROR_MSG = 'Bad checksum';\n/**\n * A constant string representing an error message for invalid base64url input.\n * This value is used to indicate that the provided input does not conform to the\n * expected base64url format or specification.\n *\n * @protected\n */\nexport const INVALID_BASE64URL_INPUT = 'Invalid base64url input';\n\n/**\n * Converts a given Uint8Array or ArrayBuffer to a Base64 URL-safe encoded string.\n *\n * @param {Uint8Array | ArrayBuffer} arr - The input data to be converted to a Base64 URL-safe string.\n * @return {string} A Base64 URL-safe encoded string representation of the input data.\n */\nexport function toBase64URL(arr: Uint8Array | ArrayBuffer): string {\n  const bytes = arr instanceof Uint8Array ? arr : new Uint8Array(arr);\n  const len = bytes.length;\n  let base64 = '';\n  for (let i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1);\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2);\n  }\n\n  return base64;\n}\n\n/**\n * Converts a Base64 URL-encoded string into a Uint8Array.\n *\n * @param {string} base64url - The Base64 URL-encoded string to be converted.\n * This string must be a valid Base64 URL-safe format.\n * @return {Uint8Array} A Uint8Array representing the decoded binary data from the input Base64 URL string.\n * @throws {Error} If the provided input is not a string or is an invalid Base64 URL format.\n */\nexport function fromBase64Url(base64url: string): Uint8Array {\n  if (typeof base64url !== 'string') {\n    throw new Error(INVALID_BASE64URL_INPUT);\n  }\n  return new Uint8Array(\n    // TODO: Cross-platform solution since atob is deprecated in Node\n    atob(base64url.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, ''))\n      .split('')\n      .map((c) => c.charCodeAt(0)),\n  );\n}\n\nfunction concatArrays(...arrs: Array<ArrayLike<number>>) {\n  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);\n  const c = new Uint8Array(size);\n\n  let offset = 0;\n  for (let i = 0; i < arrs.length; i++) {\n    c.set(arrs[i], offset);\n    offset += arrs[i].length;\n  }\n\n  return c;\n}\n\n/**\n * Encodes a given address into a string representation, including its checksum.\n *\n * @param {Uint8Array} address The public key to be encoded into an address.\n * @return {string} The encoded address as a string representation.\n *\n * @deprecated - use algo-models or algokit-utils\n */\nexport function encodeAddress(address: Uint8Array) {\n  // compute checksum\n  const checksum = sha512_256\n    .array(address)\n    .slice(\n      nacl.sign.publicKeyLength - ALGORAND_CHECKSUM_BYTE_LENGTH,\n      nacl.sign.publicKeyLength,\n    );\n  const addr = encodeBytes(concatArrays(address, checksum));\n\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param address - an Algorand address with checksum.\n * @returns the decoded form of the address's public key and checksum\n *\n * @deprecated use algo-models or algokit-utils\n */\nexport function decodeAddress(address: string): Uint8Array {\n  if (\n    typeof address !== 'string' ||\n    address.length !== ALGORAND_ADDRESS_LENGTH\n  ) {\n    throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  }\n\n  // try to decode\n  const decoded = decodeAsBytes(address.toString());\n\n  // Find publickey and checksum\n  const pk = new Uint8Array(\n    decoded.slice(\n      0,\n      ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n    ),\n  );\n  const cs = new Uint8Array(\n    decoded.slice(\n      ALGORAND_PUBLIC_KEY_BYTE_LENGTH,\n      ALGORAND_ADDRESS_BYTE_LENGTH,\n    ),\n  );\n\n  // Compute checksum\n  const checksum = sha512_256\n    .array(pk)\n    .slice(\n      HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n      HASH_BYTES_LENGTH,\n    );\n\n  // Check if the checksum and the address are equal\n  if (\n    checksum.length !== cs.length ||\n    !Array.from(checksum).every((val, i) => val === cs[i])\n  ) {\n    throw new Error(ALGORAND_ADDRESS_BAD_CHECKSUM_ERROR_MSG);\n  }\n\n  return pk;\n}\n"],"names":[],"mappings":";;;AAGA,MAAM,aAAa,aAAa,GAAG;AACnC,MAAM,QACJ;AACF,MAAM,kCAAkC;AACxC,MAAM,+BAA+B;AACrC,MAAM,gCAAgC;AACtC,MAAM,0BAA0B;AAChC,MAAM,oBAAoB;AAQnB,MAAM,8BAA8B;AASpC,MAAM,0CAA0C;AAQhD,MAAM,0BAA0B;AAQhC,SAAS,YAAY,KAAuC;AACjE,QAAM,QAAQ,eAAe,aAAa,MAAM,IAAI,WAAW,GAAG;AAClE,QAAM,MAAM,MAAM;AAClB,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK,GAAG;AAC/B,cAAU,MAAM,MAAM,CAAC,KAAK,CAAC;AACnB,cAAA,OAAQ,MAAM,CAAC,IAAI,MAAM,IAAM,MAAM,IAAI,CAAC,KAAK,CAAE;AACjD,cAAA,OAAQ,MAAM,IAAI,CAAC,IAAI,OAAO,IAAM,MAAM,IAAI,CAAC,KAAK,CAAE;AAChE,cAAU,MAAM,MAAM,IAAI,CAAC,IAAI,EAAE;AAAA,EAAA;AAG/B,MAAA,MAAM,MAAM,GAAG;AACjB,aAAS,OAAO,UAAU,GAAG,OAAO,SAAS,CAAC;AAAA,EAAA,WACrC,MAAM,MAAM,GAAG;AACxB,aAAS,OAAO,UAAU,GAAG,OAAO,SAAS,CAAC;AAAA,EAAA;AAGzC,SAAA;AACT;AAUO,SAAS,cAAc,WAA+B;AACvD,MAAA,OAAO,cAAc,UAAU;AAC3B,UAAA,IAAI,MAAM,uBAAuB;AAAA,EAAA;AAEzC,SAAO,IAAI;AAAA;AAAA,IAET,KAAK,UAAU,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG,EAAE,QAAQ,OAAO,EAAE,CAAC,EACpE,MAAM,EAAE,EACR,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAAA,EAC/B;AACF;AAEA,SAAS,gBAAgB,MAAgC;AACjD,QAAA,OAAO,KAAK,OAAO,CAAC,KAAK,QAAQ,MAAM,IAAI,QAAQ,CAAC;AACpD,QAAA,IAAI,IAAI,WAAW,IAAI;AAE7B,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,MAAE,IAAI,KAAK,CAAC,GAAG,MAAM;AACX,cAAA,KAAK,CAAC,EAAE;AAAA,EAAA;AAGb,SAAA;AACT;AAUO,SAAS,cAAc,SAAqB;AAEjD,QAAM,WAAW,WACd,MAAM,OAAO,EACb;AAAA,IACC,KAAK,KAAK,kBAAkB;AAAA,IAC5B,KAAK,KAAK;AAAA,EACZ;AACF,QAAM,OAAO,YAAY,aAAa,SAAS,QAAQ,CAAC;AAExD,SAAO,KAAK,SAAA,EAAW,MAAM,GAAG,uBAAuB;AACzD;AAQO,SAAS,cAAc,SAA6B;AACzD,MACE,OAAO,YAAY,YACnB,QAAQ,WAAW,yBACnB;AACM,UAAA,IAAI,MAAM,2BAA2B;AAAA,EAAA;AAI7C,QAAM,UAAU,cAAc,QAAQ,SAAA,CAAU;AAGhD,QAAM,KAAK,IAAI;AAAA,IACb,QAAQ;AAAA,MACN;AAAA,MACA,+BAA+B;AAAA,IAAA;AAAA,EAEnC;AACA,QAAM,KAAK,IAAI;AAAA,IACb,QAAQ;AAAA,MACN;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAGA,QAAM,WAAW,WACd,MAAM,EAAE,EACR;AAAA,IACC,oBAAoB;AAAA,IACpB;AAAA,EACF;AAGF,MACE,SAAS,WAAW,GAAG,UACvB,CAAC,MAAM,KAAK,QAAQ,EAAE,MAAM,CAAC,KAAK,MAAM,QAAQ,GAAG,CAAC,CAAC,GACrD;AACM,UAAA,IAAI,MAAM,uCAAuC;AAAA,EAAA;AAGlD,SAAA;AACT;"}